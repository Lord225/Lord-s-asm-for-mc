#profile pm1.jsonc

#global CORE0 CORE0 0
#global CORE1 CORE1 0
#data 0xF0 "PONMLKJIHGFEDCBA"

#define INPUT_ARRAY 0xF0
#define INPUT_ARRAY_END 0xFF
#define OUTPUT_ARRAY 0xE0
#define OUTPUT_ARRAY_END 0xEF
#define COUNT_ARRAY 0xD0
#define COUNT_ARRAY_END 0xDF
#define MASK 0xF
#define COUNTER 0xC0

#macro RSH4(input, output)
    rsh input, input
    rsh input, input
    rsh input, input
    rsh input, output
#endmacro

#macro DEBUG_CLEAR_REGS()
    mov 0, reg[0]
    mov 0, reg[1]
    mov 0, reg[2]
    mov 0, reg[3]
#endmacro

CORE0:
    #debug ram
    
    mov INPUT_ARRAY, reg[0]
    mov reg[0], ram[COUNTER]
    mov COUNT_ARRAY, reg[3]
    mov MASK, reg[1]

    // for (int i = 0; i < size; i++)
	// {
	//	 count[(in[i]) & 15]++;
	// }
    LOOP:
        mov ram[reg[0]], reg[2] // read val from in
        and reg[1], reg[2]      // in[i]&15
        add reg[3], reg[2]      // offset ptr
        mov ram[reg[2]], reg[0] // count[in[i]&15]
        //[COUNTER_VAL, MASK, VAL&15, COUNT_ARRAY]
        inc reg[0]
        mov reg[0], ram[reg[2]] // write
        mov ram[COUNTER], reg[0]
        inc reg[0]
        mov reg[0], ram[COUNTER]
        mov ram[INPUT_ARRAY_END], reg[2]
        jg reg[0], reg[2], LOOP

    //reg[3] - COUNT_ARRAY
    // for (int i = 1; i < 15; i++)
	// {
	//	 count[i] += count[i - 1];
	// }
    mov COUNT_ARRAY_END, reg[2] //reg[2] -> end
    LOOP2:
        mov ram[reg[3]], reg[1] // count[i-1]
        inc reg[3] //i = 1
        mov ram[reg[3]], reg[0] // count[i]
        add reg[1], reg[0]
        mov reg[0], ram[reg[3]]
        jg reg[2], reg[3], LOOP2

    // [?, ?, COUNT_ARRAY_END, COUNT_ARRAY_END]
    mov INPUT_ARRAY_END, reg[0]
    LOOP3:
        // [INPUT_ARRAY_END, -, -, -]
        mov ram[reg[0]], reg[1]
        // [INPUT_ARRAY_END, in[i], -, -]
        mov MASK, reg[2]
        // [INPUT_ARRAY_END, in[i], MASK, -]
        and reg[2], reg[1]
        // [INPUT_ARRAY_END, in[i]&15, MASK, -]
        mov COUNT_ARRAY, reg[3]
        // [INPUT_ARRAY_END, in[i]&15, MASK, COUNT_ARRAY]
        add reg[3], reg[1]
        // [INPUT_ARRAY_END, count+id&15 ptr, MASK, COUNT_ARRAY]
        mov ram[reg[0]], reg[3]
        mov reg[0], ram[COUNTER]
        // [INPUT_ARRAY_END, count+id&15 ptr, MASK, in[i]]
        mov ram[reg[1]], reg[0]
        // [count[id], count+id&15 ptr, MASK, in[i]]
        mov OUTPUT_ARRAY, reg[2]
        // [count[id]-1, count+id&15 ptr, OUTPUT_ARRAY, in[i]]
        dec reg[0]
        mov reg[0], ram[reg[1]]
        // [count[id]-1, count+id&15 ptr, OUTPUT_ARRAY, in[i]]
        add reg[2], reg[0]
        // [out+count[id]-1, count+id&15 ptr, OUTPUT_ARRAY, in[i]]
        mov reg[3], ram[reg[0]]
        mov ram[COUNTER], reg[0]
        dec reg[0]
        mov reg[0], ram[COUNTER]
        mov INPUT_ARRAY, reg[1]
        jg reg[0], reg[1], LOOP3
    // [-, -, -, -]
    mov COUNT_ARRAY_END, reg[0]
    inc reg[0]
    mov COUNT_ARRAY, reg[1]
    mov 0, reg[2]
    
    
    RESET_COUNT:
        mov reg[2], ram[reg[1]]
        inc reg[1]
        jg reg[0], reg[1], RESET_COUNT

    // Second iter
    
    mov OUTPUT_ARRAY, reg[0]
    mov reg[0], ram[COUNTER]
    mov COUNT_ARRAY, reg[3]
    mov OUTPUT_ARRAY_END, reg[1]
    
    // [OUTPUT_ARRAY*, -, -, COUNT_ARRAY*]
    LOOP_SHIFT:
        mov ram[reg[0]], reg[2] // read val from out
        RSH4(reg[2], reg[2])    // in[i]>>4
        //mov reg[0], reg[0] //NOP
        add reg[3], reg[2]      // offset ptr 
        mov ram[reg[2]], reg[0] // count[out[i]>>4]
        inc reg[0]
        mov reg[0], ram[reg[2]] // write
        mov ram[COUNTER], reg[0]
        inc reg[0]
        mov reg[0], ram[COUNTER]
        jg reg[1], reg[0], LOOP_SHIFT
        
    // cumsum
    mov COUNT_ARRAY_END, reg[2] //reg[2] -> end
    mov COUNT_ARRAY, reg[3]
    mov COUNT_ARRAY_END, reg[2] //reg[2] -> end
    
    CUMSUM_2:
        mov ram[reg[3]], reg[1] // count[i-1]
        inc reg[3]              // i = 1
        mov ram[reg[3]], reg[0] // count[i]
        add reg[1], reg[0]
        mov reg[0], ram[reg[3]]
        jg reg[2], reg[3], CUMSUM_2

    mov OUTPUT_ARRAY_END, reg[0]
    mov reg[0], ram[COUNTER] //Init COUNTER = OUTPUT_ARRAY_END
    LOOP4:
        // [COUNTER, -, -, -]
        mov ram[reg[0]], reg[1]
        mov reg[1], reg[3] // copy
        dec reg[0]
        // [COUNTER-1, out[i], -, out[i]]
        mov reg[0], ram[COUNTER] // Write
        RSH4(reg[1], reg[1])
        // [COUNTER/, out[i]>>4, -, out[i]]
        mov COUNT_ARRAY, reg[0]
        // [COUNT_ARRY, out[i]>>4, -, out[i]]
        add reg[1], reg[0]
        // [(COUNT_ARRY+out[i]>>4)*, out[i]>>4, -, out[i]]
        mov ram[reg[0]], reg[2]
        // [(COUNT_ARRY+out[i]>>4)*, out[i]>>4, COUNT_ARRY[out[i]>>4], out[i]]
        dec reg[2]
        mov reg[2], ram[reg[0]] // Write to count
        // [(COUNT_ARRY+out[i]>>4)*, out[i]>>4, COUNT_ARRY[out[i]>>4]-1, out[i]]
        mov INPUT_ARRAY, reg[0]
        // [INPUT_ARRAY*, out[i]>>4, COUNT_ARRY[out[i]>>4]-1, out[i]]
        add reg[2], reg[0]
        // [INPUT_ARRAY* + COUNT_ARRY[out[i]>>4]-1, out[i]>>4, COUNT_ARRY[out[i]>>4]-1, out[i]]
        mov reg[3], ram[reg[0]]
        mov ram[COUNTER], reg[0]
        mov OUTPUT_ARRAY, reg[1]
        jg reg[0], reg[1], LOOP4
    shut
    #debug ram
    #debug log Expected: ABCDEFGHIJKLMNOP
    #debug break
CORE1: