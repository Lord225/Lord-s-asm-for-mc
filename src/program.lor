#profile pm1.jsonc

#global CORE0 CORE0 0 11
#global CORE1 CORE1 0

#define FLAGS 0xE9
#define REDNET_DATA 0xE2
#define REDNET_ADDRESS 0xE3
#define REDNET_OUTPUT 0xE4
#define K 0x4B
#define P 0x50

    // REG[0] - wartość od komuutera o adresie 1
    // REG[1] - wartość od komuutera o adresie 2
    // REG[2] - adres REDNET_OUTPUT
    // REG[3] - 1 / wartości ascii

CORE0:

    mov 66, reg[0] //FLAG
    mov reg[0], ram[FLAGS]
    mov REDNET_OUTPUT, reg[2]
    mov 1, reg[3] 

LOOP:   
    int 0//skip?
    mov ram[reg[2]], reg[0]
    je reg[0], reg[3], ONE
    mov ram[reg[2]], reg[1]
    jmp TWO
ONE:
    mov ram[reg[2]], reg[0]
    jf SKIP1
    int 0
SKIP1:
    mov ram[reg[2]], reg[1]
    mov ram[reg[2]], reg[1]
    jmp NEXT
TWO:
    jf SKIP2
    int 0
SKIP2:
    mov ram[reg[2]], reg[0]
    mov ram[reg[2]], reg[0]

NEXT:
    je reg[0], reg[1], DRAW

    mov K, reg[3]
    je reg[0], reg[3], P1_K
    mov P, reg[3]
    je reg[0], reg[3], P1_P
    // P1_N
    jg reg[0], reg[1], P2_WIN
    jmp P1_WIN

P1_K:
    mov P, reg[3]
    je reg[1], reg[3], P2_WIN

P1_WIN:
    mov 0, reg[0]
    mov 1, reg[3]
    mov 2, reg[1]
    mov reg[3], ram[REDNET_ADDRESS]
    mov reg[3], ram[REDNET_DATA]
    mov reg[1], ram[REDNET_ADDRESS]
    mov reg[0], ram[REDNET_DATA]
    nop   //%wygral P1
    jmp LOOP 

P1_P:
    mov K, reg[3]
    je reg[1], reg[3], P1_WIN
    
P2_WIN: 
    mov 0, reg[0]
    mov 1, reg[3]
    mov 2, reg[1]
    mov reg[1], ram[REDNET_ADDRESS]
    mov reg[3], ram[REDNET_DATA]
    mov reg[3], ram[REDNET_ADDRESS]
    mov reg[0], ram[REDNET_DATA]
    nop   //%wygral P1
    jmp LOOP

DRAW:
    mov 0, reg[0]
    mov 1, reg[3]
    mov 2, reg[1]
    mov reg[3], ram[REDNET_ADDRESS]
    mov reg[0], ram[REDNET_DATA]
    mov reg[1], ram[REDNET_ADDRESS]
    mov reg[0], ram[REDNET_DATA]
    nop   //%remis
    jmp LOOP
#debug break
CORE1: