
halt
cmov reg[dst], const   
ge reg[r1], reg[r2]
ne reg[r1], reg[r2]
all y: 0
all y: reg[id]
any y: 0
any y: reg[id]
none y: 0
none y: reg[id]
bitl reg[r1], reg[r2]
bith reg[r1], reg[r2]
 
add reg[dst], reg[r1], reg[r2]
add reg[dst], reg[r1], const
sub reg[dst], reg[r1], reg[r2]
sub reg[dst], reg[r1], const
rsh reg[dst], reg[r1], reg[r2]
rsh reg[dst], reg[r1], const
lsh reg[dst], reg[r1], reg[r2]
lsh reg[dst], reg[r1], const
setbit reg[dst], reg[r1], reg[r2]
setbit reg[dst], reg[r1], const
or reg[dst], reg[r1], reg[r2]
and reg[dst], reg[r1], reg[r2]
xor reg[dst], reg[r1], reg[r2]
fadd reg[dst], reg[r1], reg[r2]
fsub reg[dst], reg[r1], reg[r2]
fmul reg[dst], reg[r1], reg[r2]
fdiv reg[dst], reg[r1], reg[r2]
ftoi reg[dst], reg[r1], reg[r2]
itof reg[dst], reg[r1], reg[r2]
utof reg[dst], reg[r1], reg[r2]

mov reg[dst], shared[const]
mov shared[const], reg[r2]
mov y: 0, reg[dst], vram[r2]
mov y: reg[id], reg[dst], vram[r2]
mov y: 0, vram[dst], const[reg[r1]] 
mov y: reg[id], vram[dst], const[reg[r1]]
mov y: 0, vram[flag], reg[r1]

par mov y: 0, vram[dst], vram[r1]
par mov y: reg[id], vram[dst], vram[r1]
par mov y: 0, vram[dst], const
par mov y: reg[id], vram[dst], const
cpar mov y: 0, vram[dst], vram[r1]
cpar mov y: reg[id], vram[dst], vram[r1]
cpar mov y: 0, vram[dst], const
cpar mov y: reg[id], vram[dst], const


    //   |0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
    //---|----------------------------------------------
    // 15|*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 14|*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 13|*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 12|*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 11|*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 10|*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 9 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 8 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 7 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 6 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 5 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 4 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 3 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 2 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 1 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 0 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *


.DRAW_RECTANGLE_USING_MASK
    // shared[0] - start_x
    // shared[1] -   end_x
    // shared[2] - start_y
    // shared[3] -   end_y
    // shared[4] -   color

    // deltax = end_x - start_x
    // mask = 1>>deltax (0->1, 1->2)
    // mask = mask - 1
    // mask = mask>>start_x
    
    mov reg[1], shared[0] //lx
    mov reg[2], shared[1] //hx
    mov reg[3], shared[2] //ly
    mov reg[4], shared[3] //lx
    mov reg[7], shared[4] //c
    
    sub reg[2], reg[2], reg[1] // deltax = end_x - start_x
    mov reg[5], 1
    rsh reg[2], reg[5], reg[2] // mask = 1>>deltax (0->1, 1->2)
    sub reg[2], 1
    rsh reg[2], reg[2], reg[1] // mask = mask>>start_x
    // 10 ticków (3s)
DRAW_LOOP:
        mov y: reg[3], vram[flag], reg[2] // set mask to reg[2]'s value
        cpar mov vram[0], reg[7]
        par show vram[0]
        inc reg[3]
        ne reg[3], reg[4]
        cjmp DRAW_LOOP // 6 ticków loop (1.82s)
    fetch
    halt
    // Rysowanie 2x2:
    // 3+1.82*2 = 6.63s
    // Rysowanie 8x8
    // 3+1.82*8 = 17.56s

.DRAW_RECTANGLE_ON_BOTTOM
    mov reg[1], shared[0] //lx
    mov reg[2], shared[1] //hx
    mov reg[7], shared[4] //c

    sub reg[2], reg[2], reg[1] // deltax = end_x - start_x
    mov reg[5], 1
    rsh reg[2], reg[5], reg[2] // mask = 1>>deltax (0->1, 1->2)
    sub reg[2], 1
    rsh reg[2], reg[2], reg[1] // mask = mask>>start_x
   
    mov y: 0, vram[flag], reg[2] // set mask to reg[2]'s value
    cpar mov vram[0], reg[7]
    par show vram[0]
    mov y: 1, vram[flag], reg[2] // set mask to reg[2]'s value
    cpar mov vram[0], reg[7]
    par show vram[0]

    fetch
    halt

    // shared[0] - 3
    // shared[1] - 6
    
    // <4.84s później:

    //   |0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
    //---|----------------------------------------------
    // 15|*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 14|*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 13|*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 12|*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 11|*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 10|*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 9 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 8 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 7 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 6 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 5 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 4 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 3 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 2 |*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    // 1 |*  *  *  #  #  #  #  *  *  *  *  *  *  *  *  *
    // 0 |*  *  *  #  #  #  #  *  *  *  *  *  *  *  *  *

.SIMD_MULTIPICATION
    // vram[0] - num1
    // vram[1] - num2
    // vram[2] - A

    // Multiply 16x 4x4bits in 6.0s
    
    // iter 1
    par and vram[3], vram[1], 1
    par eq vram[3], 1
    par cadd vram[2], vram[2], vram[0]
    par lsh vram[0], vram[0]
    par rsh vram[1], vram[1]

    // iter 2
    par and vram[3], vram[1], 1
    par eq vram[3], 1
    par cadd vram[2], vram[2], vram[0]
    par lsh vram[0], vram[0]
    par rsh vram[1], vram[1]A

    // iter 3
    par and vram[3], vram[1], 1
    par eq vram[3], 1
    par cadd vram[2], vram[2], vram[0]
    par lsh vram[0], vram[0]
    par rsh vram[1], vram[1]

    // iter 4
    par and vram[3], vram[1], 1
    par eq vram[3], 1
    par cadd vram[2], vram[2], vram[0]
    par lsh vram[0], vram[0]
    par rsh vram[1], vram[1]

